#version 450 core

const float PI=3.1415926535;
const float TWO_PI=2*PI;
const float EPSILON=0.000001;

#define NUM_SAMPLES 4096
#define INV_NUM_SAMPLES (1.0/float(NUM_SAMPLES))

layout(set=0,binding=1,rg16f) writeonly uniform image2D brdfLut;

// Compute Van der Corput radical inverse
// See: http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
float RadicalInverse_VDC(uint bits)
{
    bits = (bits<<16u) | (bits>>16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10;
}

// Sample i-th point from Hammersley point set of NumSamples points total.
vec2 SampleHammersley(uint i)
{
    return vec2(float(i) * INV_NUM_SAMPLES,RadicalInverse_VDC(i));
}

// Importance sample GGX normal distribution function for a fixed roughness value.
// For derivation see: http://blog.tobias-franke.eu/2014/03/30/notes_on_importance_sampling.html
vec3 ImportanceSampleGGX(vec2 Xi,vec3 N,float roughness)
{
    float a=roughness*roughness;
    float phi=2.0*PI*Xi.x;
	float cosTheta=sqrt((1.0-Xi.y)/(1.0+(a*a-1.0)*Xi.y));
	float sinTheta=sqrt(1.0-cosTheta*cosTheta);

	//从球体坐标转换到笛卡尔坐标
	vec3 H;
	H.x=cos(phi)*sinTheta;
	H.y=sin(phi)*sinTheta;
	H.z=cosTheta;

	//从切线坐标转换到世界坐标
	vec3 up=abs(N.z)<0.999?vec3(0.0,0.0,1.0):vec3(1.0,0.0,0.0);
	vec3 tangent=normalize(cross(up,N));
	vec3 bitangent=cross(N,tangent);

	vec3 sampleVec=tangent*H.x+bitangent*H.y+N*H.z;
	return normalize(sampleVec);
}

// Schlick-GGX approximation of geometric attenuation function using Smith's method (IBL version).
float GeometrySchlickGGX(float NdotV,float roughness)
{
	float r=roughness;
	float k=(r*r)/2.0;

	return NdotV/(NdotV*(1.0-k)+k);
}

float GeometrySmith(vec3 n,vec3 v,vec3 l,float roughness)
{
	float NdotV=max(dot(n,v),EPSILON);
	float NdotL=max(dot(n,l),EPSILON);

	return GeometrySchlickGGX(NdotL,roughness)*GeometrySchlickGGX(NdotV,roughness);
}

layout(local_size_x=32,local_size_y=32,local_size_z=1) in;
void main()
{
    float NdotV=gl_GlobalInvocationID.x/float(imageSize(brdfLut).x);
    float roughness=gl_GlobalInvocationID.y/float(imageSize(brdfLut).y);

    // Make sure viewing angle is non-zero to avoid divisions by zero (and subsequently NaNs).
    NdotV=max(NdotV,EPSILON);

    // Derive tangent-space viewing vector from angle to normal (pointing towards +Z in this reference frame).
    vec3 V=vec3(sqrt(1.0-NdotV*NdotV),0.0,NdotV);

    // We will now pre-integrate Cook-Torrance BRDF for a solid white environment and save results into a 2D LUT.
	// DFG1 & DFG2 are terms of split-sum approximation of the reflectance integral.
	// For derivation see: "Moving Frostbite to Physically Based Rendering 3.0", SIGGRAPH 2014, section 4.9.2.
	float DFG1 = 0;
	float DFG2 = 0;

    vec3 N=vec3(0.0,0.0,1.0);

    for(int i=0;i<NUM_SAMPLES;i++)
    {
        vec2 Xi=SampleHammersley(i);

        // Sample directly in tangent/shading space since we don't care about reference frame as long as it's consistent.
        vec3 H=ImportanceSampleGGX(Xi,N,roughness);

        // Compute incident direction (Li) by reflecting viewing direction (Lo) around half-vector (Lh).
		vec3 L = normalize(2.0 * dot(V, H) * H - V);

        float NdotL=max(L.z,EPSILON);
		float NdotH=max(H.z,EPSILON);
		float VdotH=max(dot(V,H),EPSILON);

        if(NdotL>EPSILON)
        {
            float G=GeometrySmith(N,V,L,roughness);
            float G_Vis=(G*VdotH)/(NdotH*NdotV);
            float Fc=pow(1.0-VdotH,5.0);

            DFG1 += (1.0-Fc) * G_Vis;
            DFG2 += Fc*G_Vis;
        }
    }

    imageStore(brdfLut,ivec2(gl_GlobalInvocationID),vec4(DFG1,DFG2,0,0)*INV_NUM_SAMPLES);
}
