#version 460

#extension GL_ARB_gpu_shader_int64 : require
#extension GL_ARB_shader_clock : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require

// Replaced by ShaderCompiler.h
#DEFINE_BLOCK

#include "Structs.glsl"

layout(location = 0) rayPayloadEXT RayPayload payload;

layout(binding = 0, set = 0) uniform accelerationStructureEXT TLAS;
layout(binding = 1, rgba32f) uniform image2D AccumulationImage;
layout(binding = 2, rgba8) uniform image2D OutputImage;
layout(binding = 10, rgba32f) uniform image2D NormalsImage;
layout(binding = 11, rgba32f) uniform image2D PositionImage;
layout(binding = 3) readonly uniform UniformBufferObject { Uniform ubo; };

#include "Random.glsl"
#include "Math.glsl"

void main() 
{
	mat4 projInv = inverse(ubo.proj);
	mat4 viewInv = inverse(ubo.view);

	float tMin     = MINIMUM;
	float tMax     = INFINITY;

	seed =initRandom(gl_LaunchSizeEXT.xy, gl_LaunchIDEXT.xy,ubo.frame);

	vec3 radiance = vec3(0);

		float r1 = rand(seed);
		float r2 = rand(seed);

		vec2 jitter     = vec2(r1, r2);

		vec2 pixel     = vec2(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y) + jitter;
		vec2 uv        = (pixel / gl_LaunchSizeEXT.xy) * 2.0 - 1.0;
		vec4 origin    = viewInv * vec4(0.0,0.0,0.0, 1.0);
		vec4 target    = projInv * vec4(uv.x, uv.y, 1.0, 1.0);
		vec4 direction = viewInv * vec4(normalize(target.xyz), 0.0);

		Ray ray = Ray(origin.xyz, direction.xyz);

		vec3 beta = vec3(1);
		vec3 absorption = vec3(0.0);
		BsdfSample bsdf;
		for (uint j = 0; j < 10; ++j)
		{
			payload.depth = j;
			payload.stop = false;
			payload.radiance = radiance;
			payload.beta = beta;
			payload.ray = ray;
			payload.bsdf = bsdf;
			payload.absorption = absorption;

			traceRayEXT(
					TLAS,           			// acceleration structure
					gl_RayFlagsOpaqueEXT,       // rayFlags
					0xFF,           			// cullMask
					0,              			// sbtRecordOffset
					0,              			// sbtRecordStride
					0,              			// missIndex
					ray.origin,     			// ray origin
					tMin,           			// ray min range
					ray.direction,  			// ray direction
					tMax,           			// ray max range
					0               			// payload (location = 0)
			);

			radiance = payload.radiance;
			beta = payload.beta;		
			ray = payload.ray;
			bsdf = payload.bsdf;
			absorption = payload.absorption;

			if (j == 0)
			{
				imageStore(NormalsImage, ivec2(gl_LaunchIDEXT.xy), vec4(payload.ffnormal, 0.0));
				imageStore(PositionImage, ivec2(gl_LaunchIDEXT.xy), vec4(payload.worldPos, 0.0));
			}

			if (payload.stop) 
				break;
		}


	// HDR scale
	vec4 accumulated = ubo.frame > 1 ? imageLoad(AccumulationImage, ivec2(gl_LaunchIDEXT.xy)) : vec4(0.0);
	vec3 accumulatedRadiance =accumulated.xyz + radiance;

	imageStore(AccumulationImage, ivec2(gl_LaunchIDEXT.xy), vec4(accumulatedRadiance, 1.0));

	radiance = accumulatedRadiance/float(ubo.frame);

	// LDR scale
	vec3 ldr = radiance;

	ldr = gammaCorrection(ldr);

	imageStore(OutputImage, ivec2(gl_LaunchIDEXT.xy), vec4(ldr, 1.f));
}
